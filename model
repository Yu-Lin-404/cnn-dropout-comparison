# 模型訓練程式碼-不含dropout
{
  "metadata": {
    "kernelspec": {
      "language": "python",
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python",
      "version": "3.7.6",
      "mimetype": "text/x-python",
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "pygments_lexer": "ipython3",
      "nbconvert_exporter": "python",
      "file_extension": ".py"
    },
    "kaggle": {
      "accelerator": "gpu",
      "dataSources": [
        {
          "sourceId": 1239356,
          "sourceType": "datasetVersion",
          "datasetId": 710593
        }
      ],
      "dockerImageVersionId": 29985,
      "isInternetEnabled": false,
      "language": "python",
      "sourceType": "notebook",
      "isGpuEnabled": true
    }
  },
  "nbformat_minor": 4,
  "nbformat": 4,
  "cells": [
    {
      "cell_type": "code",
      "source": "import pandas as pd ## Pandas Library (will use to load data,create data frame...etc).\nimport numpy as np ## Numpy Library ( will use to convert data frame to array or creating array etc...).\nimport os ## For connecting to machine to get path for reading/writing files.\nimport matplotlib.image as mpimg ## To load image.\nimport matplotlib.pyplot as plt ## For Visualizaton.\nfrom keras.preprocessing import image ## To load Image and convert it into array.\nfrom tqdm import tqdm ## To print Progress bars.\nfrom sklearn.model_selection import train_test_split ## To split train data into train and validation data.\nfrom keras.utils import to_categorical ## One hot Encoding.\nfrom keras.models import Sequential ## Sequential Model.\nfrom keras.layers import Dense ## Fully connected layer(all inputs connected to all nodes).\nfrom keras.layers import Dropout ## For Regularaization (drops couple of nodes based on integer passed to constructor).\nfrom keras.layers import Flatten ## To convert array  into 1D(one dimesional).\nfrom keras.layers import Conv2D ## Convolution two dimensional layer .\nfrom keras.layers import MaxPool2D ## fecthing important features/ reducing dimensions.\nfrom keras.optimizers import RMSprop # Optimizer.\nfrom keras.preprocessing.image import ImageDataGenerator # Image Augmentation.\nfrom keras.callbacks import ReduceLROnPlateau # Call backs/Early stopping.",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:30.737264Z",
          "iopub.execute_input": "2025-04-20T09:12:30.737568Z",
          "iopub.status.idle": "2025-04-20T09:12:37.429023Z",
          "shell.execute_reply.started": "2025-04-20T09:12:30.737539Z",
          "shell.execute_reply": "2025-04-20T09:12:37.427971Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Set max how many rows and columns you want to display in jupyter notebook.\npd.options.display.max_columns = 200 \npd.get_option('display.max_rows') \npd.set_option('display.max_rows',None)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.431212Z",
          "iopub.execute_input": "2025-04-20T09:12:37.431534Z",
          "iopub.status.idle": "2025-04-20T09:12:37.436224Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.431502Z",
          "shell.execute_reply": "2025-04-20T09:12:37.435281Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Images path.\nimage_path ='../input/hp-2020/jh_2020/images/'",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.437856Z",
          "iopub.execute_input": "2025-04-20T09:12:37.438152Z",
          "iopub.status.idle": "2025-04-20T09:12:37.447138Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.438124Z",
          "shell.execute_reply": "2025-04-20T09:12:37.446330Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "train = pd.read_csv('../input/hp-2020/jh_2020/train.csv',header='infer',sep=',')\ntest = pd.read_csv('../input/hp-2020/jh_2020/test.csv',header='infer',sep=',')",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.448765Z",
          "iopub.execute_input": "2025-04-20T09:12:37.449168Z",
          "iopub.status.idle": "2025-04-20T09:12:37.486426Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.449122Z",
          "shell.execute_reply": "2025-04-20T09:12:37.485501Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Print dimensions of train and test data.\nprint(train.shape)\nprint(test.shape)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.487602Z",
          "iopub.execute_input": "2025-04-20T09:12:37.487872Z",
          "iopub.status.idle": "2025-04-20T09:12:37.492846Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.487844Z",
          "shell.execute_reply": "2025-04-20T09:12:37.491983Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Check first record from train data.\ntrain.head()",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.494135Z",
          "iopub.execute_input": "2025-04-20T09:12:37.494448Z",
          "iopub.status.idle": "2025-04-20T09:12:37.515594Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.494380Z",
          "shell.execute_reply": "2025-04-20T09:12:37.514326Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Check last record from train data.\ntrain.tail(1)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.520167Z",
          "iopub.execute_input": "2025-04-20T09:12:37.520525Z",
          "iopub.status.idle": "2025-04-20T09:12:37.529367Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.520490Z",
          "shell.execute_reply": "2025-04-20T09:12:37.528362Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Check first record from test data.\ntest.head(1)\n",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.534254Z",
          "iopub.execute_input": "2025-04-20T09:12:37.534628Z",
          "iopub.status.idle": "2025-04-20T09:12:37.543529Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.534598Z",
          "shell.execute_reply": "2025-04-20T09:12:37.542709Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "test.tail(1)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.545230Z",
          "iopub.execute_input": "2025-04-20T09:12:37.545636Z",
          "iopub.status.idle": "2025-04-20T09:12:37.563510Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.545595Z",
          "shell.execute_reply": "2025-04-20T09:12:37.562506Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Get summary statistics of train data.\ntrain.describe(include='all')",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.564733Z",
          "iopub.execute_input": "2025-04-20T09:12:37.565013Z",
          "iopub.status.idle": "2025-04-20T09:12:37.591367Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.564988Z",
          "shell.execute_reply": "2025-04-20T09:12:37.590520Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Get summary statistics of test data.\ntest.describe(include='all')",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.592773Z",
          "iopub.execute_input": "2025-04-20T09:12:37.593086Z",
          "iopub.status.idle": "2025-04-20T09:12:37.606775Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.593057Z",
          "shell.execute_reply": "2025-04-20T09:12:37.605941Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Method will read list of images in the given path and returns image list.\ndef get_images_list(path):\n    image_list = [] ## Initialize empty list.\n    for img in tqdm(os.listdir(path)): ## Get list of image names from the given path and process each image names.\n        image_list.append(img) ## add image name to image list.\n    return image_list",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.608414Z",
          "iopub.execute_input": "2025-04-20T09:12:37.608868Z",
          "iopub.status.idle": "2025-04-20T09:12:37.616701Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.608826Z",
          "shell.execute_reply": "2025-04-20T09:12:37.615840Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Get image list for the the given path.\nimage_list = get_images_list(image_path)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.618113Z",
          "iopub.execute_input": "2025-04-20T09:12:37.618379Z",
          "iopub.status.idle": "2025-04-20T09:12:37.656303Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.618354Z",
          "shell.execute_reply": "2025-04-20T09:12:37.655422Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Print first image name from image_list.\nimage_list[0]",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.658137Z",
          "iopub.execute_input": "2025-04-20T09:12:37.658570Z",
          "iopub.status.idle": "2025-04-20T09:12:37.664640Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.658528Z",
          "shell.execute_reply": "2025-04-20T09:12:37.663774Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Plot sample images based on given image location.\ndef display_sample_images(path):\n    plt.figure(figsize=(20,6)) ## Set Figure Size.\n    for ind,image_name in tqdm(enumerate(os.listdir(path))): ## enumerate() function iterates list and return index,value.\n        img = mpimg.imread(os.path.join(path,image_name)) ## imread() reads the image from the given path and image name.\n        if ind<10: ## Based on this condition it prints only 10 images.\n            plt.subplot(2,5,ind+1) ## Add a subplot to the current figure(2 rows,5 columns and current index).\n            plt.imshow(img) ## Displays image.\n            plt.axis('off') ## Axis values will off.\n            plt.title(ind) ## Setting title name to image.",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.666190Z",
          "iopub.execute_input": "2025-04-20T09:12:37.666615Z",
          "iopub.status.idle": "2025-04-20T09:12:37.675924Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.666572Z",
          "shell.execute_reply": "2025-04-20T09:12:37.674829Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Display first 10 images.\ndisplay_sample_images(image_path)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:37.677129Z",
          "iopub.execute_input": "2025-04-20T09:12:37.677391Z",
          "iopub.status.idle": "2025-04-20T09:12:51.782481Z",
          "shell.execute_reply.started": "2025-04-20T09:12:37.677365Z",
          "shell.execute_reply": "2025-04-20T09:12:51.781178Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Image Size\nIMG_SIZE = 28",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:51.783884Z",
          "iopub.execute_input": "2025-04-20T09:12:51.784186Z",
          "iopub.status.idle": "2025-04-20T09:12:51.788827Z",
          "shell.execute_reply.started": "2025-04-20T09:12:51.784153Z",
          "shell.execute_reply": "2025-04-20T09:12:51.787675Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Load training images from the given path based on image names which are there in train data and convert them into array.\ndef load_train_data(img_path):\n    train_data = [] ## Initialize empty list\n    for img in tqdm(train['image_names']): ## Get list of image names from train data and process each image name.\n        if img in image_list: ## If the image name is present in image list then only we have to read image.\n            path = os.path.join(img_path, img) ## Location of the the image.\n            img = image.load_img(path,                              ## Load image from the given path and\n                                 target_size=(IMG_SIZE,IMG_SIZE,3), ## Keep image size as 28X28X3(height,width,color channels) and\n                                 grayscale=False)                   ## grayscale is false indicates that image is color image.\n            img = image.img_to_array(img) ## Convert image pixels into an array.\n            img = img/255 ## Normalize the train data (CNN converg faster on [0..1] data than on [0..255]).\n            train_data.append(img) ## Add normalized image pixel array to train data.      \n    return np.array(train_data) ## Convert list into an array and returns it.",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:51.790624Z",
          "iopub.execute_input": "2025-04-20T09:12:51.791015Z",
          "iopub.status.idle": "2025-04-20T09:12:51.803414Z",
          "shell.execute_reply.started": "2025-04-20T09:12:51.790975Z",
          "shell.execute_reply": "2025-04-20T09:12:51.802464Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Get training data for the given image path.\ntrain_data = load_train_data(image_path)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:51.805547Z",
          "iopub.execute_input": "2025-04-20T09:12:51.806085Z",
          "iopub.status.idle": "2025-04-20T09:12:54.886054Z",
          "shell.execute_reply.started": "2025-04-20T09:12:51.806031Z",
          "shell.execute_reply": "2025-04-20T09:12:54.885225Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Display sample train image.\nplt.imshow(train_data[1491], cmap = 'gist_gray')",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:54.887697Z",
          "iopub.execute_input": "2025-04-20T09:12:54.887986Z",
          "iopub.status.idle": "2025-04-20T09:12:55.023367Z",
          "shell.execute_reply.started": "2025-04-20T09:12:54.887957Z",
          "shell.execute_reply": "2025-04-20T09:12:55.022514Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Get size of the train_data.\nlen(train_data)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:55.024732Z",
          "iopub.execute_input": "2025-04-20T09:12:55.025027Z",
          "iopub.status.idle": "2025-04-20T09:12:55.030207Z",
          "shell.execute_reply.started": "2025-04-20T09:12:55.024997Z",
          "shell.execute_reply": "2025-04-20T09:12:55.029104Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Check image size.\nlen(image_list)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:55.031804Z",
          "iopub.execute_input": "2025-04-20T09:12:55.032210Z",
          "iopub.status.idle": "2025-04-20T09:12:55.043650Z",
          "shell.execute_reply.started": "2025-04-20T09:12:55.032167Z",
          "shell.execute_reply": "2025-04-20T09:12:55.042820Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Load testing images from the given path based on images names which are there in test data and convert them into array.\ndef load_test_data(image_path):\n    test_data = []  ## Initialize empty list\n    for img in tqdm(test['image_names']): ## Get list of image names from test data and process each image name.\n        if img in image_list: ## If the image name is present in image list then only we have to read image.\n            path = os.path.join(image_path, img) ## Location of the the image.\n            img = image.load_img(path,                              ## Load image from the given path and\n                                 target_size=(IMG_SIZE,IMG_SIZE,3), ## Keep image size as 28X28X3(height,width,color channels) and\n                                 grayscale=False)                   ## grayscale is false indicates that image is color image.\n            img = image.img_to_array(img) ## Convert image pixels into an array.\n            img = img/255 ## Normalize the test data (CNN converg faster on [0..1] data than on [0..255]).\n            test_data.append(img) ## Add normalized image pixel array to test data.\n    return np.array(test_data) ## Convert list into an array and returns it.",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:55.044924Z",
          "iopub.execute_input": "2025-04-20T09:12:55.045231Z",
          "iopub.status.idle": "2025-04-20T09:12:55.054343Z",
          "shell.execute_reply.started": "2025-04-20T09:12:55.045191Z",
          "shell.execute_reply": "2025-04-20T09:12:55.053417Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Get testing data for the given image path.\ntest_data = load_test_data(image_path)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:55.055637Z",
          "iopub.execute_input": "2025-04-20T09:12:55.055910Z",
          "iopub.status.idle": "2025-04-20T09:12:56.473953Z",
          "shell.execute_reply.started": "2025-04-20T09:12:55.055883Z",
          "shell.execute_reply": "2025-04-20T09:12:56.472962Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Display sample test image.\nplt.imshow(test_data[0], cmap = 'gist_gray')",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:56.474925Z",
          "iopub.execute_input": "2025-04-20T09:12:56.475199Z",
          "iopub.status.idle": "2025-04-20T09:12:56.614577Z",
          "shell.execute_reply.started": "2025-04-20T09:12:56.475169Z",
          "shell.execute_reply": "2025-04-20T09:12:56.613377Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Do one hot encoding on target/label varible.\ny = train['emergency_or_not'].values ## Fetch label/target values(0/1).\ny = to_categorical(y) ## Converts a class vector (integers) to binary class matrix.",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:56.616049Z",
          "iopub.execute_input": "2025-04-20T09:12:56.616456Z",
          "iopub.status.idle": "2025-04-20T09:12:56.621194Z",
          "shell.execute_reply.started": "2025-04-20T09:12:56.616423Z",
          "shell.execute_reply": "2025-04-20T09:12:56.620322Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Check sample value of target after doing one hot encoding.\ny[0]",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:56.622480Z",
          "iopub.execute_input": "2025-04-20T09:12:56.622771Z",
          "iopub.status.idle": "2025-04-20T09:12:56.636258Z",
          "shell.execute_reply.started": "2025-04-20T09:12:56.622743Z",
          "shell.execute_reply": "2025-04-20T09:12:56.635403Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Check sample record of target after doing one hot encoding.\ny[5]",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:56.637709Z",
          "iopub.execute_input": "2025-04-20T09:12:56.637996Z",
          "iopub.status.idle": "2025-04-20T09:12:56.652127Z",
          "shell.execute_reply.started": "2025-04-20T09:12:56.637967Z",
          "shell.execute_reply": "2025-04-20T09:12:56.651272Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Split the train data into train and validation data.\nX_train, X_test, y_train, y_test = train_test_split(train_data,       ## Features(i/p).\n                                                    y,                ## Traget(0/p).\n                                                    random_state=474, ## It is the seed used by the random number generator.\n                                                    test_size=0.2)    ## % of train and validation division.(80:20)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:56.653853Z",
          "iopub.execute_input": "2025-04-20T09:12:56.654209Z",
          "iopub.status.idle": "2025-04-20T09:12:56.670186Z",
          "shell.execute_reply.started": "2025-04-20T09:12:56.654158Z",
          "shell.execute_reply": "2025-04-20T09:12:56.669305Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "# Define the model structure.\n\n## Instantiate Sequential model.\nmodel = Sequential()\n\n# Convolution layer with feature map size 3X3,32 filters,input shape 28X28X3,Relu Activation function.\nmodel.add(Conv2D(32,  ##  Integer, the dimensionality of the output space (i.e. the number of output filters in the convolution).\n                 kernel_size=(3, 3), ## An integer or tuple/list of 2 integers, specifying the height and width of the 2D convolution window.Can be a single integer to specify the same value for all spatial dimensions(Feature Map).\n                 padding = 'Same', ## one of \"valid\" or \"same\" (padding is added to the frame of the image to allow for more space for the kernel to cover the image).\n                 activation='relu', ## Activation function.If you don't specify anything, no activation is applied.\n                 input_shape=(28,28,3))) ## Input shapes(28X28X3).\n\n## Convolution layer with feature map size 3X3,64 filters,Relu Activation function.\nmodel.add(Conv2D(64,\n                 kernel_size=(3, 3), \n                 padding = 'Same',\n                 activation='relu'))\n\n## Maxpooling layer with kernal size 2X2,default stride (pool_size).\nmodel.add(MaxPool2D(pool_size=(2, 2)))\n\n## Droput 25% Nodes.\n## model.add(Dropout(0.25))\n\n## Convert array data into one dimensional data.\nmodel.add(Flatten())\n\n## Fully connected layer with 128 output shape,Relu Activation function.\nmodel.add(Dense(128, activation='relu'))\n\n## Dropouts 50% Nodes.\n## model.add(Dropout(0.5))\n\n## Fully connnected layer with 2 output shape,Softmax activation function.\nmodel.add(Dense(2, activation='softmax'))",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:56.671832Z",
          "iopub.execute_input": "2025-04-20T09:12:56.672348Z",
          "iopub.status.idle": "2025-04-20T09:12:56.828611Z",
          "shell.execute_reply.started": "2025-04-20T09:12:56.672304Z",
          "shell.execute_reply": "2025-04-20T09:12:56.827276Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "# Compile the model.\nmodel.compile(loss='categorical_crossentropy',  ## String (name of objective function) or objective function or`Loss` instance.\n              optimizer='Adam',                 ## String (name of optimizer) or optimizer instance.\n              metrics=['accuracy'])             ## List of metrics to be evaluated by the model during training and testing.",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:56.830070Z",
          "iopub.execute_input": "2025-04-20T09:12:56.830503Z",
          "iopub.status.idle": "2025-04-20T09:12:56.845599Z",
          "shell.execute_reply.started": "2025-04-20T09:12:56.830459Z",
          "shell.execute_reply": "2025-04-20T09:12:56.844524Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "# Fit the model.\nmodel.fit(X_train,                            ## Input/Training data.\n          y_train,                            ## Labels/Targe/Output data.\n          epochs=30,                          ## Number of epochs to train the model.\n          validation_data=(X_test, y_test))   ## On which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data(Validation  data). ",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:12:56.847265Z",
          "iopub.execute_input": "2025-04-20T09:12:56.847701Z",
          "iopub.status.idle": "2025-04-20T09:14:21.796478Z",
          "shell.execute_reply.started": "2025-04-20T09:12:56.847657Z",
          "shell.execute_reply": "2025-04-20T09:14:21.795664Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Get predictions for test data\nprediction = model.predict_classes(test_data)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:21.797781Z",
          "iopub.execute_input": "2025-04-20T09:14:21.798080Z",
          "iopub.status.idle": "2025-04-20T09:14:22.237375Z",
          "shell.execute_reply.started": "2025-04-20T09:14:21.798050Z",
          "shell.execute_reply": "2025-04-20T09:14:22.236334Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Print first value from predictions\nprediction[0]",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.238804Z",
          "iopub.execute_input": "2025-04-20T09:14:22.239086Z",
          "iopub.status.idle": "2025-04-20T09:14:22.244514Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.239056Z",
          "shell.execute_reply": "2025-04-20T09:14:22.243592Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Copy test data into temp\ntemp = test.copy()",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.245621Z",
          "iopub.execute_input": "2025-04-20T09:14:22.245868Z",
          "iopub.status.idle": "2025-04-20T09:14:22.255240Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.245841Z",
          "shell.execute_reply": "2025-04-20T09:14:22.254241Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Add predictions data to temp data frame with 'emergency_or_not' column name\ntemp ['emergency_or_not'] = prediction",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.256374Z",
          "iopub.execute_input": "2025-04-20T09:14:22.256744Z",
          "iopub.status.idle": "2025-04-20T09:14:22.268806Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.256715Z",
          "shell.execute_reply": "2025-04-20T09:14:22.268007Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Check first 5 records from temp data\ntemp.head()",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.270422Z",
          "iopub.execute_input": "2025-04-20T09:14:22.270747Z",
          "iopub.status.idle": "2025-04-20T09:14:22.284976Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.270719Z",
          "shell.execute_reply": "2025-04-20T09:14:22.284095Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Copy 'image_names', 'emergency_or_not' columns data from temp to to_submit\nto_submit = temp[['image_names', 'emergency_or_not']]",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.286128Z",
          "iopub.execute_input": "2025-04-20T09:14:22.286369Z",
          "iopub.status.idle": "2025-04-20T09:14:22.298652Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.286346Z",
          "shell.execute_reply": "2025-04-20T09:14:22.297841Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Check the data value count for 'emergency_or_not' column\nto_submit.emergency_or_not.value_counts()",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.300335Z",
          "iopub.execute_input": "2025-04-20T09:14:22.300690Z",
          "iopub.status.idle": "2025-04-20T09:14:22.313433Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.300663Z",
          "shell.execute_reply": "2025-04-20T09:14:22.312633Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Store to_submit data into a csv file with name Keras_Predictions \nto_submit.to_csv('Keras_Predictions.csv',index = False)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.314845Z",
          "iopub.execute_input": "2025-04-20T09:14:22.315135Z",
          "iopub.status.idle": "2025-04-20T09:14:22.579798Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.315106Z",
          "shell.execute_reply": "2025-04-20T09:14:22.578900Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Set the CNN model.\n## My CNN architechture is In -> [[Conv2D->relu]*2 -> MaxPool2D -> Dropout]*2 -> Flatten -> Dense -> Dropout -> Out .\n\n## Instantiate Sequential model.\nmodel = Sequential()\n\n## Convolution layer with feature map size 5X5,32 filters,input shape 28X28X1,Relu Activation function.\nmodel.add(Conv2D(filters = 32, ## Integer, the dimensionality of the output space (i.e. the number of output filters in the convolution).\n                 kernel_size = (5,5), ## An integer or tuple/list of 2 integers, specifying the height and width of the 2D convolution window.Can be a single integer to specify the same value for 1all spatial dimensions.\n                 padding = 'Same', ## one of `\"valid\"` or `\"same\"`.\n                 activation ='relu',## Activation function.If you don't specify anything, no activation is applied.\n                 input_shape = (28,28,3))) ## input shapes(28X28X3).\n\n## Convolution layer with feature map size 5X5,32 filters,Relu Activation function.\nmodel.add(Conv2D(filters = 32,\n                 kernel_size = (5,5),\n                 padding = 'Same', \n                 activation ='relu'))\n\n## Maxpooling layer with kernal size 2X2,default stride (pool_size).\nmodel.add(MaxPool2D(pool_size=(2,2)))\n\n## Droput 25% Nodes.\n## model.add(Dropout(0.25))\n\n## Convolution layer with feature map size 3X3,64 filters,Relu Activation function.\nmodel.add(Conv2D(filters = 64,\n                 kernel_size = (3,3),\n                 padding = 'Same', \n                 activation ='relu'))\n\n## Convolution layer with feature map size 3X3,64 filters,Relu Activation function.\nmodel.add(Conv2D(filters = 64,\n                 kernel_size = (3,3),\n                 padding = 'Same', \n                 activation ='relu'))\n\n## Maxpooling layer with kernal size 2X2,Stride 2X2.\nmodel.add(MaxPool2D(pool_size=(2,2), strides=(2,2)))\n\n## Droput 25% Nodes.\n## model.add(Dropout(0.25))\n\n## Convert array data into one dimensional data.\nmodel.add(Flatten())\n\n## Fully connected layer with 256 output shape,Relu Activation function.\nmodel.add(Dense(256, activation = \"relu\"))\n\n## Dropouts 50% Nodes.\n## model.add(Dropout(0.5))\n\n## Fully connnected layer with 2 output shape,Softmax activation function.\nmodel.add(Dense(2, activation = \"softmax\"))",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.581645Z",
          "iopub.execute_input": "2025-04-20T09:14:22.582036Z",
          "iopub.status.idle": "2025-04-20T09:14:22.671956Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.581995Z",
          "shell.execute_reply": "2025-04-20T09:14:22.670915Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Define the RMSprop optimizer with leaning rate 0.001.\noptimizer = RMSprop(lr=0.001, rho=0.9, epsilon=1e-08, decay=0.0)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.673476Z",
          "iopub.execute_input": "2025-04-20T09:14:22.673891Z",
          "iopub.status.idle": "2025-04-20T09:14:22.679955Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.673850Z",
          "shell.execute_reply": "2025-04-20T09:14:22.678656Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Compile the model\nmodel.compile(optimizer = optimizer ,            ## String (name of optimizer) or optimizer instance.\n              loss = \"categorical_crossentropy\", ## String (name of objective function) or objective function or`Loss` instance. \n              metrics=[\"accuracy\"])              ## List of metrics to be evaluated by the model during training and testing.",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.681606Z",
          "iopub.execute_input": "2025-04-20T09:14:22.682018Z",
          "iopub.status.idle": "2025-04-20T09:14:22.699434Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.681987Z",
          "shell.execute_reply": "2025-04-20T09:14:22.698510Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Set a learning rate annealer\nlearning_rate_reduction = ReduceLROnPlateau(monitor='val_accuracy', ## Quantity to be monitored.\n                                            patience=3,     ## Number of epochs that produced the monitored quantity with no improvement after which training will be stopped. \n                                            verbose=1,      ## int. 0: quiet, 1: update messages.\n                                            factor=0.5,     ## Factor by which the learning rate will be reduced. new_lr = lr * factor\n                                            min_lr=0.00001) ## Lower bound on the learning rate.",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.700927Z",
          "iopub.execute_input": "2025-04-20T09:14:22.701314Z",
          "iopub.status.idle": "2025-04-20T09:14:22.707557Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.701274Z",
          "shell.execute_reply": "2025-04-20T09:14:22.706530Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Instantiate Data Augmentation\n\ndatagen = ImageDataGenerator(featurewise_center=False,            ## Set input mean to 0 over the dataset\n                             samplewise_center=False,             ## Set each sample mean to 0\n                             featurewise_std_normalization=False, ## Divide inputs by std of the dataset\n                             samplewise_std_normalization=False,  ## Divide each input by its std\n                             zca_whitening=False,                 ## Apply ZCA whitening\n                             rotation_range=10,                   ## Randomly rotate images in the range (degrees, 0 to 180)\n                             zoom_range = 0.1,                    ## Randomly zoom image \n                             width_shift_range=0.1,               ## Randomly shift images horizontally (fraction of total width)\n                             height_shift_range=0.1,              ## Randomly shift images vertically (fraction of total height)\n                             horizontal_flip=False,               ## Randomly flip images horizontally\n                             vertical_flip=False)                 ## Randomly flip images vertically\n\n## Fit data augmentation model\ndatagen.fit(X_train)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.708844Z",
          "iopub.execute_input": "2025-04-20T09:14:22.709240Z",
          "iopub.status.idle": "2025-04-20T09:14:22.726600Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.709210Z",
          "shell.execute_reply": "2025-04-20T09:14:22.725683Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "epochs = 30      ## Number of epochs to train a model\nbatch_size = 86  ## Number of sample to process at a time",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.727783Z",
          "iopub.execute_input": "2025-04-20T09:14:22.728059Z",
          "iopub.status.idle": "2025-04-20T09:14:22.735037Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.728025Z",
          "shell.execute_reply": "2025-04-20T09:14:22.734184Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Fit the model\nhistory = model.fit_generator(datagen.flow(X_train,                           ## Input data\n                                           y_train,                           ## Labels/ Target/ out put data\n                                           batch_size=batch_size),            ## Batch size (default: 32)\n                              epochs = epochs,                                ## Number of epochs to train the model.\n                              validation_data = (X_test, y_test),             ## On which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data(Validation data).\n                              verbose = 2,                                    ## 0, 1, or 2. Verbosity mode 0 = silent, 1 = progress bar, 2 = one line per epoch.\n                              steps_per_epoch=X_train.shape[0] // batch_size, ## Total number of steps (batches of samples) to yield from `generator` before declaring one epoch finished and starting the next epoch. It should typically be equal to `ceil(num_samples / batch_size)`\n                              callbacks=[learning_rate_reduction])            ## List of callbacks to apply during training.",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:14:22.736343Z",
          "iopub.execute_input": "2025-04-20T09:14:22.736673Z",
          "iopub.status.idle": "2025-04-20T09:16:49.631273Z",
          "shell.execute_reply.started": "2025-04-20T09:14:22.736643Z",
          "shell.execute_reply": "2025-04-20T09:16:49.630551Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Plot the loss and accuracy curves for training and validation data\nfig, ax = plt.subplots(2,1)\nax[0].plot(history.history['loss'], color='b', label=\"Training loss\")\nax[0].plot(history.history['val_loss'], color='r', label=\"validation loss\",axes =ax[0])\nlegend = ax[0].legend(loc='best', shadow=True)\n\nax[1].plot(history.history['accuracy'], color='b', label=\"Training accuracy\")\nax[1].plot(history.history['val_accuracy'], color='r',label=\"Validation accuracy\")\nlegend = ax[1].legend(loc='best', shadow=True)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:16:49.633006Z",
          "iopub.execute_input": "2025-04-20T09:16:49.633441Z",
          "iopub.status.idle": "2025-04-20T09:16:49.901767Z",
          "shell.execute_reply.started": "2025-04-20T09:16:49.633375Z",
          "shell.execute_reply": "2025-04-20T09:16:49.900942Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "",
      "metadata": {
        "trusted": true
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "",
      "metadata": {
        "trusted": true
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Get Predictions for test data\nresults = model.predict(test_data)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:16:49.906501Z",
          "iopub.execute_input": "2025-04-20T09:16:49.906780Z",
          "iopub.status.idle": "2025-04-20T09:16:50.711889Z",
          "shell.execute_reply.started": "2025-04-20T09:16:49.906753Z",
          "shell.execute_reply": "2025-04-20T09:16:50.711095Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Select the indix with the maximum probability\nresults = np.argmax(results,axis = 1)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:16:50.713981Z",
          "iopub.execute_input": "2025-04-20T09:16:50.714367Z",
          "iopub.status.idle": "2025-04-20T09:16:50.719200Z",
          "shell.execute_reply.started": "2025-04-20T09:16:50.714326Z",
          "shell.execute_reply": "2025-04-20T09:16:50.718148Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Copy test data into temp\ntemp = test.copy()",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:16:50.720849Z",
          "iopub.execute_input": "2025-04-20T09:16:50.721253Z",
          "iopub.status.idle": "2025-04-20T09:16:50.731340Z",
          "shell.execute_reply.started": "2025-04-20T09:16:50.721214Z",
          "shell.execute_reply": "2025-04-20T09:16:50.730482Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Add predictions data to temp data frame with 'emergency_or_not' column name\ntemp ['emergency_or_not'] = results",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:16:50.732796Z",
          "iopub.execute_input": "2025-04-20T09:16:50.733118Z",
          "iopub.status.idle": "2025-04-20T09:16:50.743366Z",
          "shell.execute_reply.started": "2025-04-20T09:16:50.733090Z",
          "shell.execute_reply": "2025-04-20T09:16:50.742591Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Copy 'image_names', 'emergency_or_not' columns data from temp to to_submit\nto_submit = temp[['image_names', 'emergency_or_not']]",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:16:50.744783Z",
          "iopub.execute_input": "2025-04-20T09:16:50.745081Z",
          "iopub.status.idle": "2025-04-20T09:16:50.757792Z",
          "shell.execute_reply.started": "2025-04-20T09:16:50.745034Z",
          "shell.execute_reply": "2025-04-20T09:16:50.756913Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Check the data value count for 'emergency_or_not' column\nto_submit.emergency_or_not.value_counts()",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:16:50.758971Z",
          "iopub.execute_input": "2025-04-20T09:16:50.759454Z",
          "iopub.status.idle": "2025-04-20T09:16:50.771734Z",
          "shell.execute_reply.started": "2025-04-20T09:16:50.759360Z",
          "shell.execute_reply": "2025-04-20T09:16:50.770846Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "## Store to_submit data into a csv file with name Keras_Predictions_With_DataAugmentation \nto_submit.to_csv('Keras_Predictions_With_DataAugmentation.csv',index = False)",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:16:50.773079Z",
          "iopub.execute_input": "2025-04-20T09:16:50.773544Z",
          "iopub.status.idle": "2025-04-20T09:16:50.782640Z",
          "shell.execute_reply.started": "2025-04-20T09:16:50.773498Z",
          "shell.execute_reply": "2025-04-20T09:16:50.781920Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "import matplotlib.pyplot as plt\n\n# 建立圖表\nplt.figure(figsize=(14, 6))\n\n# 1. 準確率圖\nplt.subplot(1, 2, 1)\nplt.plot(history.history['accuracy'], label='Training Accuracy')\nplt.plot(history.history['val_accuracy'], label='Validation Accuracy')\nplt.title('Model Accuracy (With Dropout)')\nplt.xlabel('Epoch')\nplt.ylabel('Accuracy')\nplt.legend()\n\n# 2. 損失圖\nplt.subplot(1, 2, 2)\nplt.plot(history.history['loss'], label='Training Loss')\nplt.plot(history.history['val_loss'], label='Validation Loss')\nplt.title('Model Loss (With Dropout)')\nplt.xlabel('Epoch')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:16:50.783703Z",
          "iopub.execute_input": "2025-04-20T09:16:50.783950Z",
          "iopub.status.idle": "2025-04-20T09:16:51.247868Z",
          "shell.execute_reply.started": "2025-04-20T09:16:50.783927Z",
          "shell.execute_reply": "2025-04-20T09:16:51.246685Z"
        }
      },
      "outputs": [],
      "execution_count": null
    },
    {
      "cell_type": "code",
      "source": "print(history.history['accuracy'])\nprint(history.history['val_accuracy'])\n",
      "metadata": {
        "trusted": true,
        "execution": {
          "iopub.status.busy": "2025-04-20T09:16:51.249165Z",
          "iopub.execute_input": "2025-04-20T09:16:51.249479Z",
          "iopub.status.idle": "2025-04-20T09:16:51.254582Z",
          "shell.execute_reply.started": "2025-04-20T09:16:51.249449Z",
          "shell.execute_reply": "2025-04-20T09:16:51.253524Z"
        }
      },
      "outputs": [],
      "execution_count": null
    }
  ]
}
